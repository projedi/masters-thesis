\frame {
   \frametitle{Мотивирующий пример}
   TODO: Пример, который легко ломается в хаскеле и легко чинится зависимыми типами.
}

\frame {
   \frametitle{Зависимые типы}
   System F:
   \begin{align*}
      \mathbf{Term} &::= \mathbf{Var}\ |\ \lambda x.\ \mathbf{Term}(x)\ |
                         \ \mathbf{Term}\ \mathbf{Term} \\
      \mathbf{Type} &::= \mathbf{TVar}\ |\ \mathbf{Type} \rightarrow \mathbf{Type}\ |
                         \ \forall x.\ \mathbf{Type}(x)
   \end{align*}
   \[
      \mathbf{\Gamma} \vdash \mathbf{Term} : \mathbf{Type},\quad \mathbf{\Gamma} = \mathbf{Var} : \mathbf{Type},\dots
   \]
   \pause
   Зависимые типы:
   \begin{align*}
      \mathbf{Term} ::=&\ \mathbf{Var}\\
                      |&\ \mathbf{Term}\ \mathbf{Term}\\
                      |&\ \lambda x.\ \mathbf{Term}(x)\ |\ (x : \mathbf{Term}) \rightarrow \mathbf{Term}(x)\\
                      |&\ (\mathbf{Term}, \mathbf{Term})\ |\ (x : \mathbf{Term}) \times \mathbf{Term}(x)\\
                      |&\ \mathbf{Set}
   \end{align*}
   \[
      \mathbf{\Gamma} \vdash \mathbf{Term} : \mathbf{Term},\quad \mathbf{\Gamma} = \mathbf{Var} : \mathbf{Term},\dots
   \]
}

\frame {
   \frametitle{Agda}
   Язык с зависимыми типами и синтаксисом, похожим на Haskell.
}

\frame {
   \frametitle{Agda - примеры}
   \begin{align*}
      &{\color{red}\mathbf{data}} \textit{ работает аналогично GADT в Haskell}\\
      &\mathbf{data}\ List\ (A : Set) : Set\ \mathbf{where}\\
      &\ \ \ \text{<>} : List\ A \\
      &\ \ \ \text{\_::\_} : A \rightarrow List\ A \rightarrow List\ A \\
      \\
      &{\color{red}\{\ \dots\}}\textit{ --- необязательный аргумент(компилятор сам подставит)} \\
      &\text{list-length} : \{A : Set\} \rightarrow List\ A \rightarrow Nat \\
      &\text{list-length}\ <>\ = 0 \\
      &\text{list-length}\ (x :: xs) = \text{list-length}\ xs + 1 \\
   \end{align*}
}
\frame {
   \frametitle{Agda - примеры}
   \begin{align*}
      &\mathbf{data}\ Vec\ (A : Set) : Nat \rightarrow Set\ \mathbf{where}\\
      &\ \ \ \text{nil} : Vec\ A\ 0 \\
      &\ \ \ \text{cons} : \{n : Nat\} \rightarrow A \rightarrow Vec\ A\ n \rightarrow
         Vec\ A\ (n + 1) \\
      \\
      &\text{list-to-vec} : \{A : Set\} \rightarrow (xs : List\ A) \rightarrow
         Vec\ A\ ({\color{red}\text{list-length}\ xs}) \\
      &\text{list-to-vec}\ <>\ = \text{nil}\\
      &\text{list-to-vec}\ (x::xs) = \text{cons}\ x\ (\text{list-to-vec}\ xs)\\
   \end{align*}
}
\frame {
   \frametitle{Agda - примеры}
   \begin{align*}
      &{\color{red}\{ a_1\ a_2 : A \}(b : B) \rightarrow C} \textit{ --- синтаксический сахар для }\\
      &\ \ \ \{ a_1 : A \} \rightarrow \{ a_2 : A \} \rightarrow ( b : B ) \rightarrow C\\
      \\
      &\text{zip-vec} : \{A\ B : Set\} \{n : Nat\} \rightarrow Vec\ A\ n
         \rightarrow Vec\ B\ n \rightarrow\\
      &\ \ \ Vec\ (A \times B)\ n\\
      &\text{zip-vec}\ \text{nil}\ \text{nil}\ =\ \text{nil}\\
      &\text{zip-vec}\ (\text{cons}\ x\ xs)\ (\text{cons}\ y\ ys)\ =\ 
         \text{cons}\ (x, y)\ (\text{zip-vec}\ xs\ ys)\\
      &\color{red}\text{zip-vec}\ \text{nil}\ (\text{cons}\ y\ ys)\ =\ \dots\\
      &\color{red}\text{zip-vec}\ (\text{cons}\ x\ xs)\ \text{nil}\ =\ \dots\\
      &\textit{эти 2 клоза даже написать нельзя - типы не сойдутся}
   \end{align*}
}

\frame {
   \frametitle{Agda}
   TODO: Пример с первого слайда
}

\frame {
   \frametitle{Компилятор MAlonzo}
   \begin{align*}
      &\mathbf{data}\ Vec\ (A : Set) : Nat \rightarrow Set\ \mathbf{where}\\
      &\ \ \ \text{nil} : Vec\ A\ 0 \\
      &\ \ \ \text{cons} : \{n : Nat\} \rightarrow A \rightarrow Vec\ A\ n \rightarrow
         Vec\ A\ (n + 1) \\
      &\text{vec-map} : \{A\ B : Set\} \{n : Nat\} \rightarrow (A \rightarrow B)
         \rightarrow Vec\ A\ n \rightarrow Vec\ B\ n\\
      &\text{vec-map}\ f\ \text{nil} = \text{nil} \\
      &\text{vec-map}\ f\ (\text{cons}\ x\ xs) = \text{cons}\ (f\ x)
         \ (\text{vec-map}\ f\ xs)\\
      \\
      &\mathbf{data}\ T_1\ a_0\ a_1\ a_2 = C_2\ |\ C_3\ a_0\ a_1\ a_2\\
      &\text{d}_4\ v_0\ v_1\ v_2\ v_3\ (C_2) = \text{cast}\ C_2\\
      &\text{d}_4\ v_0\ v_1\ v_2\ v_3\ (C_3\ v_4\ v_5\ v_6) = \text{cast}\ (
         C_3\ (\text{cast}\ v_4)
         \ (\text{cast}\ (v_3\ (\text{cast}\ v_5))) \\
      &\ \ \ (\text{cast}\ (\text{d}_4\ (\text{cast}\ v_0)\ (\text{cast}\ v_1)
         \ (\text{cast}\ v_4)\ (\text{cast}\ v_3)\ (\text{cast}\ v_6))))\\
      &\textbf{ghci>\ :t}\ \text{d}_4\\
      &\text{d}_4\ ::\ a \rightarrow a_1 \rightarrow a_2
         \rightarrow a_3 \rightarrow (T_1\ t\ t_1\ t_2) \rightarrow b
   \end{align*}
}

\frame {
   \frametitle{Coq}
   \begin{align*}
      &\mathbf{data}\ Vec\ a = \text{Nil}\ |\ \text{Cons}\ Nat\ a\ (Vec\ a)\\
      \\
      &\text{vecMap}\ ::\ Nat \rightarrow (a_1 \rightarrow a_2) \rightarrow Vec\ a_1
         \rightarrow Vec\ a_2\\
      &\text{vecMap}\ n\ f\ v = \\
      &\ \ \ \mathbf{case}\ v\ \mathbf{of}\\
      &\ \ \ \ \text{Nil} \rightarrow \text{Nil}\\
      &\ \ \ \ \text{Cons}\ n_0\ x\ xs \rightarrow \text{Cons}\ n_0\ (f\ x)
         \ (\text{vecMap}\ n_0\ f\ xs)\\
   \end{align*}
}

\frame {
   \frametitle{Что хочется}
   Нужно сохранить инварианты, поддерживаемые системой типов.
   \vspace{1em}
   \begin{block}{Идея}
      \begin{enumerate}
      \item Компилируем весь код в Haskell с помощью MAlonzo.
      \item
         Для выбранных имен пытаемся найти соответствующие типы на Haskell
         и генерируем обертки над скомпилированным кодом.
      \end{enumerate}
   \end{block}
}

\frame {
   \frametitle{Простое решение}
   \begin{Lem}
   Типы Agda, лежащие в System F, представимы в Haskell и имеют ту же семантику.
   \end{Lem}
   {\color{red} Формально не доказывал, но, вроде, очевидно.}

   Указание на <<экспорт>> дается с помощью прагм\\
   \texttt{\{-\# EXPORT agda-name haskell-name \#-\}}

   \begin{itemize}
   \item \(\mathbf{data}\ T\ (A : Set) : Set \rightarrow Set\ \mathbf{where}\)
      породит
      \(\mathbf{newtype}\ T\ a_0\ a_1 =\ \texttt{<hidden>}\)
   \item \(f : \{ A : Set \} \rightarrow (\{ B : Set \} \rightarrow B)
      \rightarrow A\) породит
      \(f :: \forall a_0 .\ (\forall b_0 .\ b_0) \rightarrow a_0\)
   \end{itemize}
}

\frame {
   \frametitle{Недоработки}
   Некоторые типы можно экспортировать вместе с конструкторами:\\
   \texttt{\{-\# EXPORT\_DATA agda-name hs-name hs-con-name \dots\ \#-\}}\\
   Проблема оборачивания функций:
   \begin{itemize}
   \item \textbf{newtype} гарантирует, что внутреннее представление совпадает с
      оборачиваемым типом \(\Rightarrow\) \texttt{unsafeCoerce}.
   \item \textbf{data} не может дать никаких похожих гарантий \(\Rightarrow\)
      генерирование разбора по конструкторам.
   \end{itemize}

   Из этого же --- невозможно экспортировать \(f\):
   \begin{align*}
   &\mathbf{newtype}\ T_1\ a_0 = \dots\\
   &\mathbf{data}\ T_2\ a_0 = \dots\\
   \\
   &f : \{A : Set\} \rightarrow (T_1 (T_2\ A)) \rightarrow A\\
   &\color{red}f :: \forall a.\ T_1 (T_2\ a)) \rightarrow a
   \end{align*}
}

\frame {
   \frametitle{Недоработки}
   \begin{itemize}
      \item Haskell поддерживает \(\mathbf{data}\ T\ (a :: * \rightarrow *)\)
         аналог в Agda \(\mathbf{data}\ T\ (A : Set \rightarrow Set)\)
      \item У Agda есть FFI в Haskell и есть набор встроенных типов. При компиляции
         они обрабатываются специально.
      \item В Agda eсть параметризованные модули:
         \(\mathbf{module}\ \text{Main}\ (A : Set)\ \mathbf{where}\)
      \item Сейчас все экспорты генерируются в том же модуле, что и скомпилированный
         код(\texttt{MAlonzo.Code.Module.Name}. Лучше все это вынести в отдельное
         поддерево \texttt{MAlonzo.Export.Module.Name}, чтобы экспортировать
         \textbf{newtype} абстрактно(скрыв реализацию от пользователя) и чтобы
         автоматически можно было сгенерировать документацию без мусора.
   \end{itemize}
}

\frame {
   \frametitle{А что можно попробовать}
   \begin{enumerate}
      \item разрешить экспортировать типы с конструкторами
      \item зависимые типы вроде \( f : \{A\ B : Set\}\{n : Nat\} \rightarrow Vec\ A\ n \rightarrow
         Vec\ B\ n \rightarrow Vec\ (A \times B)\ n \)
         могут быть экспортированы, если \(n\) не используется внутри \(f\)
      \item есть трюк, позволяющий экспортировать типы вроде \( f : \{A : Set\}(n : Nat) \rightarrow A \rightarrow Vec\ a\ n \)
   \end{enumerate}
}

\frame {
   \frametitle{Gotchas}
   \begin{itemize}
      \item termination checking, totality
   \end{itemize}
}

\frame {
   \center{\Huge Q\&A}
}
