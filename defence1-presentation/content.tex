\frame {
   \frametitle{Мотивирующий пример}
   TODO: Пример, который легко ломается в хаскеле и легко чинится зависимыми типами.
}

\frame {
   \frametitle{Зависимые типы}
   System F:
   \begin{align*}
      \mathbf{Term} &::= \mathbf{Var}\ |\ \lambda x.\ \mathbf{Term}(x)\ |
                         \ \mathbf{Term}\ \mathbf{Term} \\
      \mathbf{Type} &::= \mathbf{TVar}\ |\ \mathbf{Type} \rightarrow \mathbf{Type}\ |
                         \ \forall x.\ \mathbf{Type}(x)
   \end{align*}
   \pause
   Зависимые типы:
   \begin{align*}
      \mathbf{Term} ::=&\ \mathbf{Var}\\
                      |&\ \mathbf{Term}\ \mathbf{Term}\\
                      |&\ \lambda x.\ \mathbf{Term}(x)\\
                      |&\ (x : \mathbf{Term}) \rightarrow \mathbf{Term}(x)\\
                      |&\ (\mathbf{Term}, \mathbf{Term})\\
                      |&\ (x : \mathbf{Term}) \times \mathbf{Term}(x)\\
   \end{align*}
}

\frame {
   \frametitle{Agda}
   Язык с зависимыми типами и синтаксисом, похожим на Haskell.
}

\frame {
   \frametitle{Agda - примеры}
   \begin{align*}
      &\mathbf{data}\ List\ (A : Set) : Set\ \mathbf{where}\\
      &\ \ \ \text{<>} : List\ A \\
      &\ \ \ \text{\_::\_} : A \rightarrow List\ A \rightarrow List\ A \\
      \\
      &\text{list-length} : \{A : Set\} \rightarrow List\ A \rightarrow Nat \\
      &\text{list-length}\ <>\ = 0 \\
      &\text{list-length}\ (x :: xs) = \text{list-length}\ xs + 1 \\
   \end{align*}
}
\frame {
   \frametitle{Agda - примеры}
   \begin{align*}
      &\mathbf{data}\ Vec\ (A : Set) : Nat \rightarrow Set\ \mathbf{where}\\
      &\ \ \ \text{nil} : Vec\ A\ 0 \\
      &\ \ \ \text{cons} : \{n : Nat\} \rightarrow A \rightarrow Vec\ A\ n \rightarrow
         Vec\ A\ (n + 1) \\
      \\
      &\text{list-to-vec} : \{A : Set\} \rightarrow (xs : List\ A) \rightarrow
         Vec\ A\ (\text{list-length}\ xs) \\
      &\text{list-to-vec}\ <>\ = \text{nil}\\
      &\text{list-to-vec}\ (x::xs) = \text{cons}\ x\ (\text{list-to-vec}\ xs)\\
      \\
      &\text{zip-vec} : \{A\ B : Set\} \{n : Nat\} \rightarrow Vec\ A\ n
         \rightarrow Vec\ B\ n \rightarrow Vec\ (A \times B)\ n\\
      &\text{zip-vec}\ \text{nil}\ \text{nil}\ =\ \text{nil}\\
      &\text{zip-vec}\ (\text{cons}\ x\ xs)\ (\text{cons}\ y\ ys)\ =\ 
         \text{cons}\ (x, y)\ (\text{zip-vec}\ xs\ ys)\\
      &\color{red}{\text{zip-vec}\ \text{nil}\ (\text{cons}\ y\ ys)\ =\ \dots}\\
      &\color{red}{\text{zip-vec}\ (\text{cons}\ x\ xs)\ \text{nil}\ =\ \dots}\\
   \end{align*}
}

\frame {
   \frametitle{Agda}
   TODO: Пример с первого слайда
}

\frame {
   \frametitle{Компилятор MAlonzo}
   \begin{align*}
      &\mathbf{data}\ Vec\ (A : Set) : Nat \rightarrow Set\ \mathbf{where}\\
      &\ \ \ \text{nil} : Vec\ A\ 0 \\
      &\ \ \ \text{cons} : \{n : Nat\} \rightarrow A \rightarrow Vec\ A\ n \rightarrow
         Vec\ A\ (n + 1) \\
      &\text{vec-map} : \{A\ B : Set\} \{n : Nat\} \rightarrow (A \rightarrow B)
         \rightarrow Vec\ A\ n \rightarrow Vec\ B\ n\\
      &\text{vec-map}\ f\ \text{nil} = \text{nil} \\
      &\text{vec-map}\ f\ (\text{cons}\ x\ xs) = \text{cons}\ (f\ x)
         \ (\text{vec-map}\ f\ xs)\\
      \\
      &\mathbf{data}\ T_1\ a_0\ a_1\ a_2 = C_2\ |\ C_3\ a_0\ a_1\ a_2\\
      &\text{d}_4\ v_0\ v_1\ v_2\ v_3\ (C_2) = \text{cast}\ C_2\\
      &\text{d}_4\ v_0\ v_1\ v_2\ v_3\ (C_3\ v_4\ v_5\ v_6) = \text{cast}\ (
         C_3\ (\text{cast}\ v_4)
         \ (\text{cast}\ (v_3\ (\text{cast}\ v_5))) \\
      &\ \ \ (\text{cast}\ (\text{d}_4\ (\text{cast}\ v_0)\ (\text{cast}\ v_1)
         \ (\text{cast}\ v_4)\ (\text{cast}\ v_3)\ (\text{cast}\ v_6))))\\
      &\textbf{ghci>\ :t}\ \text{d}_4\\
      &\text{d}_4\ ::\ a \rightarrow a_1 \rightarrow a_2
         \rightarrow a_3 \rightarrow (T_1\ t\ t_1\ t_2) \rightarrow b
   \end{align*}
}

\frame {
   \frametitle{Coq}
   \begin{align*}
      &\mathbf{Inductive}\ \text{vec}\ (A : Set) : nat \rightarrow Set \coloneqq
         \text{nil} : \text{vec}\ A\ 0\\
      &\ |\ \text{cons} : \forall n : \text{nat},\ A \rightarrow \text{vec}\ A\ n
         \rightarrow \text{vec}\ A\ (n + 1).\\
      &\mathbf{Fixpoint}\ \text{vMap}\ (A : Set)(B : Set)n(f : A \rightarrow B)
         (v : \text{vec}\ A\ n) : \text{vec}\ B\ n \coloneqq\\
      &\ \ \ \mathbf{match}\ v\ \mathbf{with}\ \text{nil} \Rightarrow \text{nil}\ \_\\
      &\ \ \ |\ \text{cons}\ \_\ x\ xs \Rightarrow \text{cons}\ \_\ \_\ (f\ x)
         \ (\text{vMap}\ \_\ \_\ \_\ f\ xs)\\
      &\mathbf{end}.\\
      \\
      &\mathbf{data}\ Vec\ a = \text{Nil}\ |\ \text{Cons}\ Nat\ a\ (Vec\ a)\\
      &\text{vMap}\ ::\ Nat \rightarrow (a_1 \rightarrow a_2) \rightarrow Vec\ a_1
         \rightarrow Vec\ a_2\\
      &\text{vMap}\ n\ f\ v = \mathbf{case}\ v\ \mathbf{of}\\
      &\ \ \ \text{Nil} \rightarrow \text{Nil}\\
      &\ \ \ \text{Cons}\ n_0\ x\ xs \rightarrow \text{Cons}\ n_0\ (f\ x)
         \ (\text{vMap}\ n_0\ f\ xs)\\
   \end{align*}
}

\frame {
   \frametitle{Что хочется}
   Идея: Экспортировать только то, что при преобразовании типов не потеряет информацию(инварианты).

   \vspace{3em}
   Сначала разрешаем только типы, которые имеют полный аналог в Haskell.
   Потом добавляем отдельные случаи зависимых типов, представляемых в Haskell.
}

\frame {
   \frametitle{Что сделано}
   С помощью прагм \texttt{\{-\# EXPORT agda-name haskell-name \#-\}}
   можно экспортировать типы и функции(тип которых выводится автоматически).

   Но типы экспортируются только как абстрактные(\texttt{newtype}), а не с конструкторами(\texttt{data}).

   TODO: go into detail here
}

\frame {
   \frametitle{А что можно попробовать}
   \begin{enumerate}
      \item разрешить экспортировать типы с конструкторами
      \item зависимые типы вроде \( f : \{A\ B : Set\}\{n : Nat\} \rightarrow Vec\ A\ n \rightarrow
         Vec\ B\ n \rightarrow Vec\ (A \times B)\ n \)
         могут быть экспортированы, если \(n\) не используется внутри \(f\)
      \item есть трюк, позволяющий экспортировать типы вроде \( f : \{A : Set\}(n : Nat) \rightarrow A \rightarrow Vec\ a\ n \)
   \end{enumerate}
}

\frame {
   \center{\Huge Q\&A}
}
