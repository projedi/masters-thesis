\section{Введение}

\subsection{Haskell и Agda}

Haskell\footnote{\url{http://haskell.org}} --- функциональный язык программирования
общего назначения.

Agda\footnote{\url{http://wiki.portal.chalmers.se/agda/pmwiki.php?n=Main.HomePage}} ---
функциональный язык программирования с зависимыми типами и, одновременно, ---
система компьютерного доказательства теорем.

\subsection{TODO: Зависимые типы?}

\subsection{Экстракция кода}\label{sec:intro-extraction}

Термин <<экстракция программ>> пришел из языка/cистемы доказательства теорем
Coq\footnote{\url{http://coq.inria.fr}}, похожего на Agda, и означает генерацию функционального кода
из доказательств \cite{Let02}.

\subsection{Применение экстракции}

Можно выделить 2 основных причины для реализации механизма экстракции:
\begin{enumerate}
\item \textbf{Техника генерирования верифицированных библиотек}

      На системах с зависимыми типами вроде Agda и Coq можно строить
      сложные логические утверждения, которые будут проверяться на этапе
      проверки типов (за счет чего эти системы помогают формально доказывать теоремы).
      Таким образом, можно написать библиотеку на таком языке с набором доказанных
      свойств и после этого сделать экстракцию в язык вроде Haskell или ML,
      на которых проще писать <<реальные>> программы.

\item \textbf{Бесплатная компилируемость}

      Скомпилированный код как правило работает быстрее интерпретации, а умение
      транслировать код в компилируемый язык освобождает от сложной задачи
      написания компилятора с нуля.
\end{enumerate}

В этой работе фокус ставится на первый пункт.

\newpage
\section{Постановка задачи}

\subsection{Цель}\label{sec:task-goal}

Разработать способ вызывать код, написанный на Agda, из Haskell, не нарушая
внутренних инвариантов, установленных Agda.

Про сохранение внутренних инвариантов нужно объяснить подробнее. Рассмотрим пример:
\begin{align*}
&\mathbf{data}\ Nat : Set\ \mathbf{where}\\
&\quad zero : Nat\\
&\quad succ : Nat \rightarrow Nat\\
\\
&\mathbf{data}\ List\ (A : Set) : Set\ \mathbf{where}\\
&\quad nil : List\ A\\
&\quad cons : A \rightarrow List\ A \rightarrow List\ A\\
\\
&length : \forall\ \{A\} \rightarrow List\ A \rightarrow Nat\\
&length\ nil = zero\\
&length\ (cons\ \_\ xs) = succ\ (length\ xs)\\
\\
&\mathbf{data}\ Fin : Nat \rightarrow Set\ \mathbf{where}\\
&\quad finzero : \forall\ \{n\} \rightarrow Fin\ (succ\ n)\\
&\quad finsucc : \forall\ \{n\} \rightarrow Fin\ n \rightarrow Fin\ (succ\ n)\\
\\
&elemAt : \forall\ \{A\}\ (xs : List\ A) \rightarrow Fin\ (length\ xs) \rightarrow A\\
&elemAt\ nil\ ()\\
&elemAt\ (cons\ x\ \_)\ finzero = x\\
&elemAt\ (cons\ \_\ xs)\ (finsucc\ n) = elemAt\ xs\ n
\end{align*}

В этом коде определяются три типа данных: натуральныe числа,
список и конечные числа (тип \(Fin\ n\) имеют числа, меньшие \(n\)) и
2 функции: длина списка и получение элемента из списка по индексу.
Рассмотрим вторую функцию. Она принимает 2 аргумента: список и число,
меньшее длины списка. Это гарантирует, что элемент с таким индексом
существует. Этот инвариант используется в самом первом клозе:
при попытке написать код для пустого списка, Agda замечает, что нет способа
построить терм с типом \(Fin\ zero\) и поэтому можно написать \(()\) вместо тела
и система типов гарантирует, что \(elemAt\) никогда не будет вызвана с
аргументом \(nil\).

При экстракции в Haskell хочется сохранить это свойство. Но эта функция
использует зависимые типы, которые не получится воспроизвести на Haskell.
Поэтому, нужно запретить вызывать эту функцию из внешнего кода.

\subsection{Существующие решения}

\subsubsection{Для Coq}

Как было сказано в пункте \ref{sec:intro-extraction} в Coq есть технология
<<экстракции программ>>. Но текущая реализация стирает все зависимые типы и
код аналогичный \ref{sec:task-goal} будет преобразован в: TODO: actually test with Coq
\begin{align*}
&\dots\\
&\mathbf{data}\ Fin = FinZero\ |\ FinSucc\ Fin\\
&elemAt :: List\ a \rightarrow Fin \rightarrow a\\
&\dots
\end{align*}

И теперь можно вызвать \(elemAt\) от пустого списка и получить ошибку на
этапе выполнения, что нежелательно.

\subsubsection{Для Agda}

На Agda есть компилятор
MAlonzo\footnote{\url{http://thread.gmane.org/gmane.comp.lang.agda/62}}
(являющийся переписанным компилятором Alonzo\cite{Ben07}), который транслирует
код на Agda в код на Haskell и затем компилирует его с помощью ghc, получая в
результате исполняемый файл.

\subsection{Анализ MAlonzo}

TODO: Full description of MAlonzo internals.

\subsection{Задачи}

\begin{enumerate}
\item Реализовать
\item ???
\item PROFIT
\end{enumerate}

TODO: Mention somewhere that the goal is to create a system
TODO: that does not break invariants set up by Agda.

\newpage
\section{Реализация}

\subsection{Архитектура}

Вместо изменения кодогенерации в MAlonzo было решено сгенерировать
обертки, имеющие нужный интерфейс и вызывающие код MAlonzo. Это
позволит менять меньше кода в MAlonzo, но это внесет проблемы с производительностью.

Решение является частью MAlonzo, код встроен на трех участках пути:
\begin{enumerate}
\item при начале обработки модуля вызывается обнуление контекста,
\item при обработке каждого определения верхнего уровня вызывается
      функция, проверяющая надо ли генерировать обертку для данного определения,
\item при окончании обработки модуля, если необходимо генерировать код, создается
      новый модуль, в который помещаются все обертки.
\end{enumerate}

\subsection{TODO: ???}

\subsection{TODO: PROFIT... Ha! See what I did there? No? I will go now...}

\newpage
\section{Заключение}

\subsection{Выводы}

\subsection{Дальнейшая разработка}
