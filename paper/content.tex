\section{Введение}

\subsection{Haskell и Agda}

Haskell\footnote{\url{http://haskell.org}} --- функциональный язык программирования
общего назначения.

Agda\footnote{\url{http://wiki.portal.chalmers.se/agda/pmwiki.php?n=Main.HomePage}} ---
функциональный язык программирования с зависимыми типами и, одновременно, ---
система компьютерного доказательства теорем.

\subsection{TODO: Зависимые типы?}

\subsection{Экстракция кода}

Термин <<экстракция программ>> пришел из языка/cистемы доказательства теорем
Coq\footnote{\url{http://coq.inria.fr}}, похожего на Agda, и означает генерацию функционального кода
из доказательств \cite{Let02}.

\subsection{Применение экстракции}

Можно выделить 2 основных причины для реализации механизма экстракции:
\begin{enumerate}
\item \textbf{Техника генерирования верифицированных библиотек}

      На системах с зависимыми типами вроде Agda и Coq можно строить
      сложные логические утверждения, которые будут проверяться на этапе
      проверки типов (за счет чего эти системы помогают формально доказывать теоремы).
      Таким образом, можно написать библиотеку на таком языке с набором доказанных
      свойств и после этого сделать экстракцию в язык вроде Haskell или ML,
      на которых проще писать <<реальные>> программы.

\item \textbf{Бесплатная компилируемость}

      Скомпилированный код как правило работает быстрее интерпретации, а умение
      транслировать код в компилируемый язык освобождает от сложной задачи
      написания компилятора с нуля.
\end{enumerate}

В этой работе фокус ставится на первый пункт.

\newpage
\section{Постановка задачи}

\subsection{Цель}

Разработать способ вызывать код, написанный на Agda, из Haskell.

\subsection{Существующие решения}

\subsubsection{Для Coq}

Coq очень похож на Agda и поэтому имеет смысл сравнивать их технологии.

Техника называется <<экстракция программ>>\cite{Let02}.
По программам на Coq генерируются программы на OCaml, Haskell и Scheme.
При этом все вычисления, выполняемые только на этапе проверки типов, стираются.
То есть, все зависимые типы, и, как следствие, доказательства.

\subsubsection{Для Agda}

На Agda есть компилятор
MAlonzo\footnote{\url{http://thread.gmane.org/gmane.comp.lang.agda/62}}
(являющийся переписанным компилятором Alonzo\cite{Ben07}), который транслирует
код на Agda в код на Haskell и затем компилирует его с помощью ghc, получая в
результате исполняемый файл.

\subsection{Анализ MAlonzo}

TODO: Full description of MAlonzo internals.

\subsection{Задачи}

\begin{enumerate}
\item Реализовать
\item ???
\item PROFIT
\end{enumerate}

TODO: Mention somewhere that the goal is to create a system
TODO: that does not break invariants set up by Agda.

\newpage
\section{Реализация}

\subsection{Архитектура}

Вместо изменения кодогенерации в MAlonzo было решено сгенерировать
обертки, имеющие нужный интерфейс и вызывающие код MAlonzo. Это
позволит менять меньше кода в MAlonzo, но это внесет проблемы с производительностью.

Решение является частью MAlonzo, код встроен на трех участках пути:
\begin{enumerate}
\item при начале обработки модуля вызывается обнуление контекста,
\item при обработке каждого определения верхнего уровня вызывается
      функция, проверяющая надо ли генерировать обертку для данного определения,
\item при окончании обработки модуля, если необходимо генерировать код, создается
      новый модуль, в который помещаются все обертки.
\end{enumerate}

\subsection{TODO: ???}

\subsection{TODO: PROFIT... Ha! See what I did there? No? I will go now...}

\newpage
\section{Заключение}

\subsection{Выводы}

\subsection{Дальнейшая разработка}
