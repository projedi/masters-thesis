\section{Доказательство корректности}\label{sec:appendix-proof}

\subsection{Кайнды}

\begin{thm}
Если
\[
KT\llbracket AgdaType \rrbracket = HaskellKind
\]
определена, то существует такой тип \(HaskellType\) в Haskell, что
\[
HaskellType :: HaskellKind.
\]
\end{thm}

\begin{proof}
Структурная индукция по \(AgdaType\):
\begin{description}
\item[\(Set_0\):] Тогда \(HaskellKind = *\) и
   \[
   \mathbf{data}\ HaskellType :: *.
   \]
\item[\(S_1 \rightarrow S_2\):] Пусть
   \begin{align*}
   K_1 &= KT\llbracket S_1 \rrbracket,\\
   K_2 &= KT\llbracket S_2 \rrbracket.
   \end{align*}
   Если \(K_1\) или \(K_2\) не определены, то \(KT\llbracket AgdaType \rrbracket\)
   не определена. Иначе, \(HaskellKind = K_1 \rightarrow K_2\) и существуют
   \begin{align*}
   &\mathbf{data}\ HaskellType_1 :: K_1\text{ и}\\
   &\mathbf{data}\ HaskellType_2 :: K_2.
   \end{align*}
   Мы всегда можем добавить к типу данных еще один параметр. Добавим один к
   \(HaskellType_2\):
   \[
   \mathbf{data}\ HaskellType\ (a :: K_1) :: K_2.
   \]
   Это тоже валидный тип на Haskell, поскольку на место \(a\) можно подставить
   \(HaskellKind_1\) и его кайнд будет \(K_1 \rightarrow K_2 = HaskellKind\).
\item[\textnormal{иначе}:] \(KT\llbracket AgdaType \rrbracket\) не определена.
\end{description}
\end{proof}

\subsection{Объявление типов}

\begin{thm}
Если определено \(DT\llbracket AgdaTypeName \rrbracket = HaskellTypeName\), то
можно использовать \texttt{unsafeCoerce} для преобразования между\\
\(HaskellTypeName\) и внутренним представлением \(AgdaTypeName\) в MAlonzo.
\end{thm}

\begin{proof}
Если \(DT\llbracket AgdaTypeName \rrbracket = ExternalHaskellTypeName\) определено,
то определено \(DTD\llbracket AgdaTypeName \rrbracket\) как \texttt{newtype}-обертка
над \(DTMA\llbracket AgdaTypeName \rrbracket = InternalHaskellTypeName\).
Тогда гарантируется\footnote{
\url{https://www.haskell.org/onlinereport/haskell2010/haskellch4.html\#x10-740004.2.3}},
что термы с типами \(ExternalHaskellTypeName\) и \(InternalHaskellTypeName\) будут иметь
одинаковое внутреннее представление. Значит, можно использовать \texttt{unsafeCoerce}.
\end{proof}

\subsection{Встроенные типы}

\begin{thm}
Если определена \(BTMA\llbracket B \rrbracket(AgdaType) = HaskellType\) для
некоторого \(B \in Builtins\), то можно использовать \texttt{unsafeCoerce}
для преобразования между \(HaskellType\) и внутренним представлением \(AgdaType\) в
MAlonzo.
\end{thm}

\begin{proof}
Если определена \texttt{\{-\# BUILTIN B \(AgdaType\) \#-\}} для \(B \in Builtins\),
то MAlonzo при генерации кода на месте \(AgdaType\) будет использовать
\(BTMA\llbracket B \rrbracket(AgdaType)\). Таким образом, \texttt{unsafeCoerce}
использовать безопасно, так как тип один и тот же.
\end{proof}

\subsection{Импортированные типы}

\begin{thm}
Если определена\\ \(CTMA\llbracket AgdaTypeName \rrbracket = HaskellTypeName\), то
можно использовать \texttt{unsafeCoerce} для преобразования между
\(HaskellTypeName\) и внутренним представлением \(AgdaTypeName\) в MAlonzo.
\end{thm}

\begin{proof}
Если определена\\ \texttt{\{-\# COMPILED\_TYPE \(AgdaTypeName\) \(HaskellTypeName\) \#-\}}
или\\ \texttt{\{-\# COMPILED\_DATA \(AgdaTypeName\) \(HaskellTypeName\)\\
\(HaskellConstructor\)\dots\ \#-\}},
то MAlonzo при генерации кода на месте\\ \(AgdaTypeName\) будет использовать
\(HaskellTypeName\). Таким образом,\\ \texttt{unsafeCoerce}
использовать безопасно, так как тип один и тот же.
\end{proof}

\subsection{Функции}

\begin{thm}
Если определено \(VT\llbracket AgdaName \rrbracket = HaskellName\), то
вызов \(HaskellName\) будет эквивалентен вызову \(AgdaName\) с соответствующими
аргументами.
\end{thm}

Это утверждение, в том числе, означает, что все инварианты, поддерживаемые Agda,
сохраняются. Поскольку набор аргументов, нарушающий инварианты, запрещен для вызова
в Adga, он так же должен быть запрещен для вызова в Haskell.

TODO: Add remark that this holds as long as MAlonzo does not change denotational semantics.

\begin{proof}
TODO
\end{proof}
