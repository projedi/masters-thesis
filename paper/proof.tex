\section{Доказательство корректности}\label{sec:appendix-proof}

\subsection{Кайнды}

\begin{thm}
Если
\[
KT\llbracket AgdaType \rrbracket = HaskellKind
\]
определена, то существует такой тип \(HaskellType\) в Haskell, что
\[
HaskellType :: HaskellKind.
\]
\end{thm}

\begin{proof}
Структурная индукция по \(AgdaType\):
\begin{description}
\item[\(Set_0\):] Тогда \(HaskellKind = *\) и
   \[
   \mathbf{data}\ HaskellType :: *.
   \]
\item[\(S_1 \rightarrow S_2\):] Пусть
   \begin{align*}
   K_1 &= KT\llbracket S_1 \rrbracket,\\
   K_2 &= KT\llbracket S_2 \rrbracket.
   \end{align*}
   Если \(K_1\) или \(K_2\) не определены, то \(KT\llbracket AgdaType \rrbracket\)
   не определена. Иначе, \(HaskellKind = K_1 \rightarrow K_2\) и существуют
   \begin{align*}
   &\mathbf{data}\ HaskellType_1 :: K_1\text{ и}\\
   &\mathbf{data}\ HaskellType_2 :: K_2.
   \end{align*}
   Мы всегда можем добавить к типу данных еще один параметр. Добавим один к
   \(HaskellType_2\):
   \[
   \mathbf{data}\ HaskellType\ (a :: K_1) :: K_2.
   \]
   Это тоже валидный тип на Haskell, поскольку на место \(a\) можно подставить
   \(HaskellKind_1\) и его кайнд будет \(K_1 \rightarrow K_2 = HaskellKind\).
\item[\textnormal{иначе}:] \(KT\llbracket AgdaType \rrbracket\) не определена.
\end{description}
\end{proof}

\subsection{Объявление типов}

\begin{thm}
Если определено \(DT\llbracket AgdaTypeName \rrbracket = HaskellTypeName\), то
можно использовать \texttt{unsafeCoerce} для преобразования между\\
\(HaskellTypeName\) и внутренним представлением \(AgdaTypeName\) в MAlonzo.
\end{thm}

\begin{proof}
Если \(DT\llbracket AgdaTypeName \rrbracket = ExternalHaskellTypeName\) определено,
то определено \(DTD\llbracket AgdaTypeName \rrbracket\) как \texttt{newtype}-обертка
над \(DTMA\llbracket AgdaTypeName \rrbracket = InternalHaskellTypeName\).
Тогда гарантируется\footnote{
\url{https://www.haskell.org/onlinereport/haskell2010/haskellch4.html\#x10-740004.2.3}},
что термы с типами \(ExternalHaskellTypeName\) и \\\(InternalHaskellTypeName\) будут иметь
одинаковое внутреннее представление. Значит, можно использовать \texttt{unsafeCoerce}.
\end{proof}

\subsection{Встроенные типы}

\begin{thm}
Если определена \(BTMA\llbracket B \rrbracket(AgdaType) = HaskellType\) для
некоторого \(B \in Builtins\), то можно использовать \texttt{unsafeCoerce}
для преобразования между \(HaskellType\) и внутренним представлением \(AgdaType\) в
MAlonzo.
\end{thm}

\begin{proof}
Если определена \texttt{\{-\# BUILTIN B \(AgdaType\) \#-\}} для \(B \in Builtins\),
то MAlonzo при генерации кода на месте \(AgdaType\) будет использовать
\(BTMA\llbracket B \rrbracket(AgdaType)\). Таким образом, \texttt{unsafeCoerce}
использовать безопасно, так как тип один и тот же.
\end{proof}

\subsection{Импортированные типы}

\begin{thm}
Если определена\\ \(CTMA\llbracket AgdaTypeName \rrbracket = HaskellTypeName\), то
можно использовать \texttt{unsafeCoerce} для преобразования между
\(HaskellTypeName\) и внутренним представлением \(AgdaTypeName\) в MAlonzo.
\end{thm}

\begin{proof}
Если определена\\ \texttt{\{-\# COMPILED\_TYPE \(AgdaTypeName\) \(HaskellTypeName\) \#-\}}
или\\ \texttt{\{-\# COMPILED\_DATA \(AgdaTypeName\) \(HaskellTypeName\)\\
\(HaskellConstructor\)\dots\ \#-\}},
то MAlonzo при генерации кода на месте\\ \(AgdaTypeName\) будет использовать
\(HaskellTypeName\). Таким образом,\\ \texttt{unsafeCoerce}
использовать безопасно, так как тип один и тот же.
\end{proof}

\subsection{Функции}

\begin{thm}
Если определены \(VT\llbracket AgdaName \rrbracket = HaskellName\) и\\
\(VTD\llbracket AgdaName \rrbracket\), то вызов \(HaskellName\) будет
эквивалентен вызову \\\(AgdaName\) с соответствующими аргументами.
\end{thm}

Это утверждение, в том числе, означает, что все инварианты, поддерживаемые Agda,
сохраняются. Поскольку набор аргументов, нарушающий инварианты, запрещен для вызова
в Agda, он так же должен быть запрещен для вызова в Haskell.

TODO: Add remark that this holds as long as MAlonzo does not change denotational semantics.

\begin{proof}
Пусть функция \(AgdaName\) определена с типом \(AgdaType\).
Структурная индукция по \(AgdaType\):
\begin{description}
\item[\(T\ args\dots,\quad T \textnormal{ --- типовой параметр}\):]
\item[\(T\ args\dots,\quad T \textnormal{ --- импортированный тип}\):]
\item[\(T\ args\dots,\quad T \textnormal{ --- экспортированный тип}\):]
\item[\(T\ args\dots,\quad T \textnormal{ --- встроенный тип}\):]
\item[\((A : S) \rightarrow T\):]
\item[\((x : T_1) \rightarrow T_2\):]
\item[\textnormal{иначе}:]
   тип \(\forall \Gamma.\ TT\llbracket AgdaType \rrbracket(\Gamma)\)
   не определен, а значит \(VTD\llbracket AgdaName \rrbracket\) тоже
   не определено.
\end{description}
\end{proof}

TODO: NO impredicative types. RankNTypes do not allow impredicativity: paper\cite{SPJ11}

TODO: Example when impredicative types break stuff. It's pretty much the problem with
data but when instead of type parameter we have a ((A : Set) -> A -> A). MAlonzo and
generated interface generate (forall a. () -> a -> a) and (forall a. a -> a). Cannot
unsafeCoerce between them.

TODO: Why the trick with data does not work for just functions:
\begin{itemize}
\item One polymorphic and one specialized function. One puts a thing in. The other
      gets it out. Therefore in one way we use bijection, in other --- unsafeCoerce.
\item When we do not hide (forall a. a -> a) inside a datatype we have to store it
      in a function(e.g. pair: ((a -> (forall b. b -> b) -> c) -> c). But we do not
      allow to return a function - we always split it into arguments. That is always
      run our bijection for it.
\end{itemize}
