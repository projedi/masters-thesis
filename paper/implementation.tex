\section{Реализация}

\subsection{Генерирование ограниченного интерфейса}

Как обсуждалось в \ref{text:limited-interface}, необходим способ ограничивать
функционал генерируемого интерфейса, чтобы выставлять только те элементы,
использование которых не может нарушить внутренние инварианты системы.

Еще необходимо уметь генерировать имена для получаемого интерфейса:
правила именования в Agda и Haskell отличаются.

Поэтому было решено ввести прагму
\[
\texttt{\{-\# EXPORT \(AgdaName\) \(HaskellName\) \#-\}},
\]
которая пишется в том же модуле \(AgdaModuleName\), где определяется \(AgdaName\).

Если тип \(AgdaName\) не может быть сконвертирован в аналогичный тип на Haskell
или \(HaskellName\) не соблюдает правила именования, то компиляция завершится с ошибкой.

На этапе компиляции вместе с \texttt{MAlonzo.Code.\(AgdaModuleName\)}, где хранится
код генерируемый MAlonzo, будет сгенерирован \texttt{MAlonzo.Export.\(AgdaModuleName\)},
в котором находится весь генерируемый интерфейс.

Решение создать отдельный модуль \texttt{MAlonzo.Export} вызвано желанием скрыть
сгенерированный MAlonzo код от пользователя. В том числе это позволит
при генерировании документации с помощью
haddock\footnote{\url{http://www.haskell.org/haddock/}} отображать только желаемый
интерфейс.

\subsection{Встраивание в MAlonzo}

Вместо изменения кода, который генерирует MAlonzo было решено генерировать
обертки, имеющие нужный интерфейс и вызывающие код, сгенерированный MAlonzo.
Это позволяет менять меньше кода в MAlonzo, хотя может повлиять на производительность ---
оборачивание функций может быть не отброшено оптимизатором.

Кодогенерация вызывается на следующих участках:
\begin{enumerate}
\item При начале обработки модуля \(AgdaModuleName\) компилятором MAlonzo,
      контекст, содержащий сгенерированный код, обнуляется.
\item После обработки каждого определения \(AgdaName\): функции или типа данных -
      проверяется наличие прагмы \texttt{\{-\# EXPORT \(AgdaName\) \(HaskellName\) \#-\}}.
      Если она не найдена, это определение пропускается; иначе - выполняется проверка
      на возможность сгенерировать интерфейс на Haskell. При неудаче выдается ошибка,
      иначе - в контекст добавляется сгенерированные обертки.
\item После обработки модуля, если контекст не пуст, создается модуль \texttt{MAlonzo.Export.\(AgdaModuleName\)}
      в который записывается код контекста.
\end{enumerate}

\subsection{Выполняемая кодогенерация}

Формально задается в приложении \ref{sec:appendix-transformations}.
Корректность доказывается в приложении \ref{sec:appendix-proof}.

\subsubsection{Типы данных}\label{sec:implementation-datatypes}

В \ref{sec:task-hiding-constructors} говорилось, что некоторые типы данных
(вводимые в Agda с помощью \textbf{data} и \textbf{record}) можно
представить в Haskell, только если cделать их абстрактными.

Конкретнее, если объявление типа имеет вид:
\[
\mathbf{data}\ AgdaName\ (A_0 : S_0) \cdots (A_m : S_m) :
S_{m+1} \rightarrow \cdots \rightarrow S_n \rightarrow Set_0\ \mathbf{where}\ \dots,
\]
где \(S_i\) - комбинация \(Set_0\) и \(\rightarrow\), то аналогичным объявлением
на Haskell будет:
\[
\mathbf{newtype}\ HaskellName\ (a_0 :: K_0) \cdots (a_n :: K_n) = \dots,
\]
где \(K_i\) - \(S_i\), в котором \(Set_0\) заменяется на \(*\).
Введенное ограничение на \(S_i\) гарантирует, что такой тип представим
в Haskell: индукция по \(K\)
\begin{description}
\item[\(*\): ]
\[
\mathbf{data}\ T :: *
\]
\item[\(K_1 \rightarrow K_2\): ]
\[
\mathbf{data}\ T\ (a :: K_1) :: K_2
\]
\end{description}

Теперь, MAlonzo по \(AgdaName\) сгенерирует
\[
\mathbf{data}\ T_k\ a_0 \cdots a_p = \dots
\]
и если сгенерировать
\begin{align*}
&\mathbf{newtype}\ HaskellName\ (a_0 :: K_0) \cdots (a_n :: K_n) = \\
&\quad HaskellName\ (\mathbf{forall}\ b_0 \cdots b_p .\ T_k\ b_0 \cdots b_p),
\end{align*}
то для трансформации между термом из MAlonzo, имеющим тип \(T_k\ args\dots\) и
термом, выставленным наружу, имеющим соответствующий тип \(HaskellName\ args\dots\)
можно использовать \texttt{unsafeCoerce}, так как \textbf{newtype} гарантирует
идентичное внутреннее представление. Как будет видно в
\ref{sec:implementation-functions}, это очень удобно и является причиной
почему все типы данных выставляются как \textbf{newtype} обертки.

\subsubsection{Функции}\label{sec:implementation-functions}

Типы функций \(T\), представимые в Haskell, имеют следующий вид:
\begin{align*}
&(A : S) \rightarrow T,\quad\text{\(S\) состоит из \(Set_0\) и \(\rightarrow\)}\\
&X\ args\dots,\quad\text{\(args\) представимы и \(X\) --- типовой параметр,
тип из \ref{sec:implementation-datatypes},}\\
&\qquad\text{FFI-импортированный тип или встроенный тип}\\
&(x : T_1) \rightarrow T_2,\quad x \not\in freevars(T_2)\\
&(x : T_1,\ T_2),\quad x \not\in freevars(T_2)
\end{align*}

На Haskell последние три будут иметь вид
\begin{align*}
&X\ args\dots\\
&T_1 \rightarrow T_2\\
&(T_1,\ T_2),
\end{align*}
то есть абсолютно эквивалентны оригинальным.

Для первого может быть 2 способа:
\begin{enumerate}
\item \( \forall a.\ () \rightarrow T \)
\item \( \forall a.\ T \)
\end{enumerate}

Первый используется в Agda 2.3.4, как описано в \ref{text:agda-compiled-export}.
Второй --- в данной работе.

Добавление аргумента \(()\) делает терм более похожим на Agda, так как в ней
требуется передача типового аргумента терму и этот способ используется в
MAlonzo при генерации кода. С другой стороны, второй способ является более
естественным при использовании из Haskell, но требует написания оберток над
кодом, сгенерированным MAlonzo, которые будут выполнять преобразование между
2-мя типами.

TODO: Why there is no EXPORT of types with constructors and builtins with constructors.
