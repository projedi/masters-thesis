\section{Реализация}

\subsection{Анализ MAlonzo}

TODO: Full description of MAlonzo internals.

\subsection{Генерирование ограниченного интерфейса}

Как обсуждалось в \ref{text:limited-interface}, необходим способ ограничивать
функционал генерируемого интерфейса, чтобы выставлять только те элементы,
использование которых не может нарушить внутренние инварианты системы.

Также необходимо уметь генерировать имена для получаемого интерфейса:
правила именования в Agda и Haskell отличаются.

Поэтому, было решено ввести прагму
\[
\texttt{\{-\# EXPORT \(AgdaName\) \(HaskellName\) \#-\}},
\]
которая пишется в том же модуле \(AgdaModuleName\), где определяется \\\(AgdaName\).

Если cущность \(AgdaName\) не может быть сконвертирована в аналогичную на Haskell
или \(HaskellName\) не соблюдает правила именования, то компиляция завершится с ошибкой.

На этапе компиляции вместе с \texttt{MAlonzo.Code.\(AgdaModuleName\)}, где хранится
код генерируемый MAlonzo, будет сгенерирован \\\texttt{MAlonzo.Export.\(AgdaModuleName\)},
в котором находится весь генерируемый интерфейс.

Решение создать отдельный модуль \texttt{MAlonzo.Export} вызвано желанием скрыть
сгенерированный MAlonzo код от пользователя. В том числе это позволит
при генерировании документации с помощью
haddock\footnote{\url{http://www.haskell.org/haddock/}} отображать только желаемый
интерфейс.

\subsection{Встраивание в MAlonzo}

Вместо изменения кода, который генерирует MAlonzo было решено генерировать
обертки, имеющие нужный интерфейс и вызывающие код, сгенерированный MAlonzo.
Это позволяет менять меньше кода в MAlonzo, хотя может повлиять на производительность:
оборачивание функций может быть не отброшено оптимизатором.

Кодогенерация вызывается на следующих участках:
\begin{enumerate}
\item При начале обработки модуля \(AgdaModuleName\) компилятором MAlonzo,
      контекст, содержащий сгенерированный код, обнуляется.
\item После обработки каждого определения \(AgdaName\): функции или типа данных ---
      проверяется наличие прагмы \\\texttt{\{-\# EXPORT \(AgdaName\) \(HaskellName\) \#-\}}.
      Если она не найдена, это определение пропускается; иначе - выполняется проверка
      на возможность сгенерировать интерфейс на Haskell. При неудаче выдается ошибка,
      иначе - в контекст добавляется сгенерированные обертки.
\item После обработки модуля, если контекст не пуст, создается модуль\\
      \texttt{MAlonzo.Export.\(AgdaModuleName\)}, в который записывается код из контекста.
\end{enumerate}

\subsection{Выполняемая кодогенерация}

Формально задается в приложении \ref{sec:appendix-transformations}.
Корректность доказывается в приложении \ref{sec:appendix-proof}.

\subsubsection{Типы данных}\label{sec:implementation-datatypes}

В \ref{sec:task-hiding-constructors} говорилось, что некоторые типы данных
(вводимые в Agda с помощью \textbf{data} и \textbf{record}) можно
представить в Haskell, только если cделать их абстрактными.

Конкретнее, если объявление типа имеет вид:
\[
\mathbf{data}\ AgdaName\ (A_0 : S_0) \cdots (A_m : S_m) :
S_{m+1} \rightarrow \cdots \rightarrow S_n \rightarrow Set_0\ \mathbf{where}\ \dots,
\]
где \(S_i\) - комбинация \(Set_0\)\footnote{\(Set_0\) --- консервативный выбор}
и \(\rightarrow\), то аналогичным объявлением на Haskell будет:
\[
\mathbf{newtype}\ HaskellName\ (a_0 :: K_0) \cdots (a_n :: K_n) = \dots,
\]
где \(K_i\) --- \(S_i\), в котором \(Set_0\) заменяется на \(*\).
Введенное ограничение на \(S_i\) гарантирует, что такой тип представим
в Haskell: структурная индукция по \(K\)
\begin{description}
\item[\(*\): ]
\[
\mathbf{data}\ T :: *
\]
\item[\(K_0 \rightarrow \cdots \rightarrow K_n \rightarrow *\): ]
\[
\mathbf{data}\ T\ (a_0 :: K_0) \ldots (a_n :: K_n) :: *.
\]
\(K_i\) представимы по индукции.
\end{description}

Теперь, MAlonzo по \(AgdaName\) сгенерирует
\[
\mathbf{data}\ T_k\ a_0 \cdots a_p = \dots
\]
и если сгенерировать
\begin{align*}
&\mathbf{newtype}\ HaskellName\ (a_0 :: K_0) \cdots (a_n :: K_n) = \\
&\quad HaskellName\ (\mathbf{forall}\ b_0 \cdots b_p .\ T_k\ b_0 \cdots b_p),
\end{align*}
то для трансформации между термом из MAlonzo, имеющим тип \(T_k\ args\dots\) и
термом, выставленным наружу, имеющим тип \(HaskellName\ args\dots\)
можно использовать \texttt{unsafeCoerce}, так как \textbf{newtype} гарантирует\footnote{
\url{https://www.haskell.org/onlinereport/haskell2010/haskellch4.html\#x10-740004.2.3}}
идентичное внутреннее представление. Как будет видно в
\ref{sec:implementation-wrappers}, это очень удобно и является причиной
почему все типы данных выставляются как \textbf{newtype} обертки.

\subsubsection{Функции}\label{sec:implementation-functions}

Типы функций \(T\), представимые в Haskell, имеют следующий вид:
\begin{align*}
&(A : S) \rightarrow T,\quad\text{\(S\) состоит из \(Set_0\) и \(\rightarrow\)}\\
&X\ args\dots,\quad\text{\(args\) представимы и \(X\) --- типовой параметр,
тип из \ref{sec:implementation-datatypes},}\\
&\qquad\text{FFI-импортированный тип или встроенный тип}\\
&(x : T_1) \rightarrow T_2,\quad x \not\in freevars(T_2)\\
&(x : T_1,\ T_2),\quad x \not\in freevars(T_2)
\end{align*}

\paragraph{Типы зависимой функции и зависимой пары с неиспользуемыми аргументами}
На Haskell будут иметь вид
\begin{align*}
&T_1 \rightarrow T_2\\
&(T_1,\ T_2),
\end{align*}
то есть, абсолютно эквивалентны оригинальным.

\paragraph{Объявление типового параметра}
Для \((A : S) \rightarrow T\) рассмотрим 2 способа:
\begin{enumerate}
\item \( \forall a.\ () \rightarrow T \)
\item \( \forall (a :: K).\ T,\quad K\) --- \(S\), где \(Set_0\) заменяется на \(*\)
\end{enumerate}

Первый используется в Agda 2.3.4, как описано в \ref{text:agda-compiled-export}.
Второй --- в данной работе.

Добавление аргумента \(()\) делает терм более похожим на Agda, так как в ней
требуется передача типового аргумента терму и этот способ используется в
MAlonzo при генерации кода. С другой стороны, второй способ является более
естественным при использовании из Haskell, но требует написания оберток над
кодом, сгенерированным MAlonzo, которые будут выполнять преобразование между
2-мя типами.

\paragraph{Типовой атом}
Разбивается на 4 случая:
\begin{enumerate}
\item \textbf{Типовой параметр}

Заменяется на переменную из соответствующего объявления
\item \textbf{<<Экспортированный>> тип}

Заменяется на тип, в который экспортировали
\item \textbf{<<Импортированный>> тип}

Заменяется на тип, из которого импортировали с помощью \texttt{COMPILED\_DATA} или
\texttt{COMPILED\_TYPE}
\item \textbf{Встроенный тип}

Встроенные типы, получаемые из постулатов: \texttt{INTEGER}, \texttt{FLOAT},
\texttt{CHAR}, \texttt{STRING}, \texttt{IO} - заменяются соответственно на
\(Int\), \(Float\), \(Char\), \(String\), \(IO\), так как MAlonzo использует
ровно эти типы вместо постулатов.

Встроенные типы вроде \texttt{LIST} в MAlonzo просто получают функции
по преобразованию между \([]\) и типом, сгенерированным по обычным правилам
и таким образом эквивалентны генерированию экспорту типов вместе с конструкторами.
\end{enumerate}

\subsubsection{Обертки для функций}\label{sec:implementation-wrappers}

TODO: Why there is no EXPORT of types with constructors and builtins with constructors.
