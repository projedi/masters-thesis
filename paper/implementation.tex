\section{Реализация}

\subsection{Генерирование ограниченного интерфейса}

Как обсуждалось в \ref{sec:task-goal}, необходим способ ограничивать
функционал генерируемого интерфейса, чтобы выставлять только те элементы,
использование которых не может нарушить внутренние инварианты системы.

Еще необходимо уметь генерировать имена для получаемого интерфейса:
правила именования в Agda и Haskell отличаются.

Поэтому было решено ввести прагму
\[
\texttt{\{-\# EXPORT \(AgdaName\) \(HaskellName\) \#-\}},
\]
которая пишется в том же модуле \(AgdaModuleName\), где определяется \(AgdaName\).

Если тип \(AgdaName\) не может быть сконвертирован в аналогичный тип на Haskell
или \(HaskellName\) не соблюдает правила именования, то компиляция завершится с ошибкой.

На этапе компиляции вместе с \texttt{MAlonzo.Code.\(AgdaModuleName\)}, где хранится
код генерируемый MAlonzo, будет сгенерирован \texttt{MAlonzo.Export.\(AgdaModuleName\)},
в котором находится весь генерируемый интерфейс.

Решение создать отдельный модуль \texttt{MAlonzo.Export} вызвано желанием скрыть
сгенерированный MAlonzo код от пользователя. В том числе это позволит
при генерировании документации с помощью haddock\footnote{\url{http://www.haskell.org/haddock/}}
отображать только желаемый интерфейс.

\subsection{Архитектура}

Вместо изменения кодогенерации в MAlonzo было решено сгенерировать
обертки, имеющие нужный интерфейс и вызывающие код MAlonzo. Это
позволит менять меньше кода в MAlonzo, но это внесет проблемы с производительностью.

Решение является частью MAlonzo, код встроен на трех участках пути:
\begin{enumerate}
\item при начале обработки модуля вызывается обнуление контекста,
\item при обработке каждого определения верхнего уровня вызывается
      функция, проверяющая надо ли генерировать обертку для данного определения,
\item при окончании обработки модуля, если необходимо генерировать код, создается
      новый модуль, в который помещаются все обертки.
\end{enumerate}

\subsection{Конвертирование}

Формально задается в \ref{sec:appendix-transformations}.

\subsubsection{Типы данных}

Типы данных (\textbf{data}, \textbf{record}) экспортируются как \textbf{newtype},
а не \textbf{data}.

\subsubsection{Функции}

Полиморфизм по-Черчу преобразуется в полиморфизм по-Карри.
