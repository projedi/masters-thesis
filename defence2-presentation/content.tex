\frame {
   \frametitle{Формальная верификация}

   \begin{itemize}
   \item Необходимо уметь убеждаться, что написанная программа решает
         поставленную задачу.
   \item Тестирование не может показать, что программа верна для всех случаев
         (если, конечно, нельзя сделать полный перебор).
   \item Формальная верификация позволяет сравнить программу с формальной
         математической моделью и доказать их эквивалентность на всех входных данных.
   \end{itemize}
}

\frame {
   \frametitle{Agda}

   \begin{itemize}
   \item Один из способов формально верифицировать --- строить формулы достаточно
         мощной логики над элементами программы и проверять их на этапе компиляции.
   \item Agda позволяет строить формулы на языке предикативной конструктивной логики.
         TODO: Definition of predicative logic?
   \end{itemize}
}

\frame {
   \frametitle{Использование верифицированного кода}

   Написание верифицированного алгоритма недостаточно --- необходимо еще
   использовать этот код из <<реальных>> приложений. Подходы:
   \begin{enumerate}
   \item Использовать Agda для написания приложений целиком.
         \begin{description}
         \item[\(+\)] Можно верифицировать больше кода.
         \item[\(-\)] Не Тьюринг-полный язык.
         \end{description}
   \item По коду на Agda генерировать код на другом языке
         \begin{description}
         \item[\(+\)] Удобнее писать <<реальный>> код.
         \item[\(-\)] Необходимо поддерживать корректность кода при трансляции.
         \end{description}
   \end{enumerate}

   Второй пункт называется <<экстракция программ>> и используется в системе Coq.
}

\frame {
   \frametitle{Постановка задачи}

   По коду на Agda получить код на Haskell, который можно использовать
   из программы на Haskell, не нарушая внутренние инварианты, поддерживаемые Agda.

   TODO: Why Haskell

   TODO: This means we need to forbid exporting some functions and datatypes
}

\frame {
   \frametitle{Существующие решения}

   \begin{description}
   \item[Coq]
      Экстракция программ\footnote{P. Letouzey. \emph{A New Extraction for Coq}. 2002}.
      Генерируется код, из которого стираются все доказательства.
      Но это значит, что некоторые функции, требовавшие инварианты
      на этапе компиляции, теперь будут их требовать на этапе исполнения.
   \item[Agda 2.3.2.2]
      Компилятор MAlonzo\footnote{
      \url{http://thread.gmane.org/gmane.comp.lang.agda/62}}. Фокусируется
      на генерировании исполняемых файлов через трансляцию в Haskell.
      Генерирует имена вида буква+число, теряет всю информацию о типах (кроме
      арности функций).
   \item[Agda 2.3.4]
      Появилась возможность давать пользовательские имена функциям
      и генерировать для них разумные типы.
   \end{description}
}

\frame {
   \frametitle{Цели и задачи}

   \begin{block}{Цель работы}
      Разработать механизм для MAlonzo, генерирующий интерфейс на Haskell к коду
      на Agda, использование которого не позволит нарушить инварианты, поддерживаемые
      Agda.
   \end{block}

   Задачи:
   \begin{enumerate}
   \item Разобраться с принципом кодогенерации в MAlonzo.
   \item Разработать способ генерировать интерфейс из выделенных функций и типов данных
         и на этапе компиляции проверять, что он не нарушает инварианты.
   \item Доказать корректность выполняемых трансформаций.
   \item Реализовать и протестировать.
   \end{enumerate}
}

\frame {
   \frametitle{Реализация}

   \begin{itemize}
   \item Выставляемый интерфейс представляет собой обертки над кодом,
         сгенерированным MAlonzo, которые имеют типы, поддерживающие те
         же инварианты, что требует код на Agda.
   \item Язык Agda расширен прагмой
         \texttt{\{-\# EXPORT \(AgdaName\) \(HaskellName\) \#-\}}, которой
         передается имя из Agda и желаемое имя в Haskell. Если сущность
         \(AgdaName\) представима в Haskell и \(HaskellName\) --- разрешенное
         имя для этой сущности, то во время компиляции генерируется
         соответствующая обертка.
   \item Для модуля \(AgdaModuleName\) код интерфейса помещается в
         модуль \(MAlonzo.Export.AgdaModuleName\), чтобы отделить
         код, сгенерированный MAlonzo (находящийся в
         \(MAlonzo.Code.AgdaModuleName\)) от безопасного интерфейса.
   \end{itemize}
}

\frame {
   \frametitle{Выполняемые трансляции}
   \framesubtitle{Объявления типов}
}

\frame {
   \frametitle{Выполняемые трансляции}
   \framesubtitle{Типы функций}
}

\frame {
   \frametitle{Выполняемые трансляции}
   \framesubtitle{Термы функций}
}

\frame {
   \frametitle{Выводы}

}

\frame {
   \frametitle{EXTRA - Agda 2.3.4 COMPILED\_EXPORT}

   TODO: What does it generate?
}
