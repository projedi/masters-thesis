\frame {
   \frametitle{Формальная верификация}

   \begin{itemize}
   \item Необходимо уметь убеждаться, что написанная программа решает
         поставленную задачу.
   \item Тестирование не может показать, что программа верна для всех случаев
         (если, конечно, нельзя сделать полный перебор).
   \item Формальная верификация позволяет сравнить программу с формальной
         математической моделью и доказать их эквивалентность на всех входных данных.
   \end{itemize}
}

\frame {
   \frametitle{Agda}

   \begin{itemize}
   \item Один из способов формально верифицировать --- строить формулы достаточно
         мощной логики над элементами программы и проверять их на этапе компиляции.
   \item Agda --- функциональный язык программирования, который позволяет строить
         формулы на языке предикативной конструктивной логики.
   \end{itemize}
}

\frame {
   \frametitle{Использование верифицированного кода}

   Написание верифицированного алгоритма недостаточно --- необходимо еще
   использовать этот код из <<реальных>> приложений. Подходы:
   \begin{enumerate}
   \item Использовать Agda для написания приложений целиком.
         \begin{description}
         \item[\(+\)] Можно верифицировать больше кода.
         \item[\(-\)] Не Тьюринг-полный язык.
         \end{description}
   \item По коду на Agda генерировать код на другом языке
         \begin{description}
         \item[\(+\)] Удобнее писать <<реальный>> код.
         \item[\(-\)] Необходимо поддерживать корректность кода при трансляции.
         \end{description}
   \end{enumerate}

   Второй пункт называется <<экстракция программ>> и используется в системе Coq.
}

\frame {
   \frametitle{Постановка задачи}

   \begin{block}{Задача}
      По коду на Agda получить код на Haskell, который можно использовать
      из программы на Haskell, не нарушая внутренние инварианты, поддерживаемые Agda.
   \end{block}

   Целевым языком выбран Haskell по нескольким причинам:
   \begin{itemize}
   \item Языки синтаксически похожи
   \item Типы в Haskell --- подмножество типов в Agda
   \item Часть работы уже сделана
   \end{itemize}

   Поскольку на Agda можно потребовать от аргументов функций свойств, не представимых
   в Haskell, то необходимо уметь запрещать давать прямой доступ к ним. Иначе,
   можно будет передать неправильный (с точки зрения Agda) аргумент, который пройдет
   проверку типов на стороне Haskell, и получить падение программы на этапе исполнения.
}

\frame {
   \frametitle{Существующие решения}

   \begin{description}
   \item[Coq 8.4pl3]
      Экстракция программ\footnote{P. Letouzey. \emph{A New Extraction for Coq}. 2002}.
      Генерируется код, из которого стираются все доказательства.
      Но это значит, что некоторые функции, требовавшие инварианты
      на этапе компиляции, теперь будут их требовать на этапе исполнения.
   \item[Agda 2.3.2.2]
      Компилятор MAlonzo\footnote{
      \url{http://thread.gmane.org/gmane.comp.lang.agda/62}}. Фокусируется
      на генерировании исполняемых файлов через трансляцию в Haskell.
      Генерирует имена вида буква+число, теряет всю информацию о типах (кроме
      арности функций).
   \item[Agda 2.3.4]
      Появилась возможность давать пользовательские имена функциям
      и генерировать для них разумные типы.
   \end{description}
}

\frame {
   \frametitle{Цели и задачи}

   \begin{block}{Цель работы}
      Разработать механизм для MAlonzo, генерирующий интерфейс на Haskell к коду
      на Agda, использование которого не позволит нарушить инварианты, поддерживаемые
      Agda.
   \end{block}

   Задачи:
   \begin{enumerate}
   \item Разобраться с принципом кодогенерации в MAlonzo.
   \item Разработать способ генерировать интерфейс из выделенных функций и типов данных
         и на этапе компиляции проверять, что он не нарушает инварианты.
   \item Доказать корректность выполняемых трансформаций.
   \item Реализовать и протестировать.
   \end{enumerate}
}

\frame {
   \frametitle{Обзор реализации}

   \begin{itemize}
   \item Выставляемый интерфейс представляет собой обертки над кодом,
         сгенерированным MAlonzo, которые имеют типы, поддерживающие те
         же инварианты, что требует код на Agda.
   \item Язык Agda расширен прагмой
         \texttt{\{-\# EXPORT \(AgdaName\) \(HaskellName\) \#-\}}, которой
         передается имя из Agda и желаемое имя в Haskell. Если сущность
         \(AgdaName\) представима в Haskell и \(HaskellName\) --- разрешенное
         имя для этой сущности, то во время компиляции генерируется
         соответствующая обертка.
   \item Для модуля \(AgdaModuleName\) код интерфейса помещается в
         модуль \(MAlonzo.Export.AgdaModuleName\), чтобы отделить
         код, сгенерированный MAlonzo (находящийся в
         \(MAlonzo.Code.AgdaModuleName\)) от безопасного интерфейса.
   \end{itemize}
}

\frame {
   \frametitle{Выводы}

   Таким образом, разработан способ генерировать безопасный интерфейс на Haskell
   к коду на Agda и доказана его корректность.
}

\frame {
   \frametitle{EXTRA - Выполняемые трансляции}
   \framesubtitle{Объявления типов}
}

\frame {
   \frametitle{EXTRA - Выполняемые трансляции}
   \framesubtitle{Типы функций}
}

\frame {
   \frametitle{EXTRA - Выполняемые трансляции}
   \framesubtitle{Термы функций}
}

\frame {
   \frametitle{EXTRA - Agda 2.3.4 COMPILED\_EXPORT}

   TODO: What does it generate?
}

\frame {
   \frametitle{EXTRA - Что дальше}

   TODO: Extracting data with constructors
   TODO: Typeclasses and instances
   TODO: More dependent type emulation
}
