2. Необходимо уметь проверять правильность работы программы.
   Тестирования может не хватить - оно может только показать,
   что программа работает правильно на таком-то наборе данных.
   Аппарат формальной верификации позволяет доказать корректность
   для любого входа.

3. Один из способов верификации - построение логических формул над
   элементами программы и проверка их на этапе компиляции.
   Agda - язык программирования, позволяющий делать ровно это.

4. Но написать верифицированный код - мало. Нужно еще его как-то
   использовать из реального кода. Есть 2 способа:
   использовать Agda для написания всего кода полностью, но это вообще
   говоря невозможно - язык не Тьюринг-полный; или по коду на Agda генерировать
   код, сохраняющий семантику, на каком-нибудь другом языке. Этот подход называется
   в литературе "экстракция программ".

5. Таким образом, задача: По коду на Agda получить код на Haskell, который можно
   было бы использовать из другой программы на Haskell, не нарушая инвариантов,
   поддерживаемых Agda. Haskell был выбран в основном потому что больша'я часть
   работы уже сделана - существует транслятор из Agda в Haskell.

6. Теперь, на Agda можно от аргументов функций требовать свойств, не выражаемых на
   Haskell. Значит, необходимо уметь скрывать такие функции от внешнего кода. Иначе
   можно было бы передать в такую функцию аргумент валидный с точки зрения Haskell,
   но неправильный с точки зрения Agda и получить падение на этапе исполнения.

7. Существующие решения. В системе Coq (похожей на Agda) есть механизм экстракции.
   Используется следующий подход:
   по коду на Coq генерируется код на Haskell, из которого стираются все доказательства и
   нетривиальные инварианты. Но это влечет проблему, описанную ранее: можно передать
   аргумент, ломающий подразумеваемые инварианты и получить падение при исполнении.
   В Agda есть MAlonzo - транслятор фокусирующийся на генерировании исполняемых файлов. Как
   следствие, он генерирует имена в духе буква+число и стирает всю информацию о типах.
   Работа велась над версией 2.3.2.2, как оказалось параллельно шла похожая работа в
   самой Agda и c версии 2.3.4 там появится возможность давать функциям запрашиваемые
   имена и генерировать для них разумные типы. Но наши подходы немного отличаются.

8. Таким образом, цель данной работы разработать механизм для MAlonzo, позволяющий
   генерировать интерфейс на Haskell к коду Agda, как бы который не использовать,
   не позволяющий нарушить внутренние инварианты Agda.
   Отсюда вытекают задачи: разобраться, как MAlonzo генерирует код;
   разработать способ генерировать безопасный интерфейс к нему; доказать корректность,
   реализовать и протестировать.

9. Обзор реализации. Интерфейс было решено сделать обертками над кодом, генерируемым
   MAlonzo, которым приписываются соответствующие типы, чтобы уменьшить число кода,
   который нужно менять в MAlonzo. Сам язык расширен прагмой, которой передается
   имя из Agda и желаемое имя в Haskell. Если конструкция с тем именем представима в
   Haskell и ей можно дать запрашиваемое имя, то генерируется соответствующая обертка.
   Иначе - ошибка компиляции. Все обертки помещаются в отдельный модуль, отличный от
   того, где генерируется код MAlonzo, чтобы явно отделить опасный код из MAlonzo от
   безопасного интерфейса.

10. Теперь подробнее об обертках. Если тип и все его конструкторы представимы в Haskell,
    то этот тип можно полностью задать на Haskell и использовать все возможности, в том
    числе pattern matching. Но тогда для реализации потребуется либо подменять код,
    генерируемый MAlonzo, либо генерировать биекцию для использования в обертках функций.

11. Если же тип представим на Haskell, но хотя бы один его конструктор не представим, то
    приходится ограничиваться генерированием абстрактного типа данных, то есть скрывать
    от пользователя конструкторы и терять возможность делать pattern matching.
    Зато для реализации можно использовать следующий трюк: генерировать newtype обертку
    над типом MAlonzo и использовать unsafeCoerce для конвертирования между ними.
    Этот способ сейчас используется и для генерирования простых типов.

12. Теперь о генерировании оберток функций. И в Agda, и в Haskell есть параметрический
    полиморфизм, но его реализация отличается: Agda требует передавать параметр типа в
    качестве аргумента функции. MAlonzo при генерировании кода оставляет этот
    дополнительный аргумент, но он всегда будет иметь значение (). Если оставлять этот
    аргумент в генерируемом интерфейсе, то пользователю придется передавать и пропускать
    его вручную. Поэтому, было решено генерировать обертки, которые делают это
    автоматически.

13. По итогам работы. Разработан способ генерировать безопасный интерфейс на Haskell
    к Agda и доказана его корректность. Спасибо за внимание.

Проблемы:
* МНОГО ТЕКСТА на слайде - хотят примеры и просто сделать их дополнением к моей речи.
* Упоминание о доказательстве до выводов.
* Не акцентировать постановку задачи.
* Меньше введения.
