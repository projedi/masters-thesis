\section{Intro}

I need to prove that haskell types and terms that I expose wouldn't break the system.  It means two things:
\begin{enumerate}
\item Types preserve the same set of invariants
\item Terms have the same interface: any combination of \texttt{APPLY} that can be used(ignoring types) to original
      term must be usable with generated one; and primitives(numbers, strings, ... and their ops) are the same.
\end{enumerate}

\section{My transformations}

Transformation for kinds:
\[ KT\llbracket Kind \rrbracket = HaskellKind \]

\begin{align*}
   KT\llbracket Set \rrbracket &= *\\
   KT\llbracket Set_0 \rrbracket &= *\\
   KT\llbracket Kind_1 \rightarrow Kind_2 \rrbracket &=
      KT\llbracket Kind_1 \rrbracket \rightarrow KT\llbracket Kind_2 \rrbracket\\
   KT\llbracket \_ \rrbracket &= \bot
\end{align*}

Transformation for types:
\[ TT\llbracket AgdaType \rrbracket(Context) = HaskellType \]

\begin{align*}
   TT\llbracket A\ args\ldots \rrbracket(\Gamma) &= a\ TT\llbracket args\ldots \rrbracket(\Gamma),
      \quad (A \mapsto a) \in \Gamma \\
   TT\llbracket CT\ args\ldots \rrbracket(\Gamma) &= CT\ TT\llbracket args\ldots \rrbracket(\Gamma),
      \quad CT\text{ is a \texttt{COMPILED\_TYPE}, \texttt{EXPORT} or a primitive postulate}\\
   TT\llbracket (A : Kind) \rightarrow T \rrbracket(\Gamma) &= \forall (a :: KT\llbracket Kind \rrbracket).
      \ TT\llbracket T \rrbracket(\Gamma \cup (A \mapsto a))\\
   TT\llbracket (x : T_1) \rightarrow T_2 \rrbracket(\Gamma) &=
      TT\llbracket T_1 \rrbracket(\Gamma) \rightarrow TT\llbracket T_2 \rrbracket(\Gamma),
      \quad x \not\in freevars(T_2) \\
   TT\llbracket (x : T_1,\ T_2) \rrbracket(\Gamma) &=
      (TT\llbracket T_1 \rrbracket(\Gamma),\ TT\llbracket T_2 \rrbracket(\Gamma)),
      \quad x \not\in freevars(T_2) \\
   TT\llbracket \_ \rrbracket(\Gamma) &= \bot\\
\end{align*}

Transformation for datatype declaration:
\begin{align*}
   &DT\llbracket AgdaType \rrbracket = HaskellTypeDeclaration\\
   &DTMA\llbracket AgdaType \rrbracket = HaskellType,
      \quad \text{--- MAlonzo transformation}
\end{align*}

Observing two declarations:
\begin{align*}
   &\textbf{data } AgdaDataType\ (A_1 : Kind_1) \cdots (A_n : Kind_n) :
      Kind_{n+1} \rightarrow \cdots \rightarrow Kind_{m} \rightarrow Set \textbf{ where } \ldots\\
   &\textbf{record } AgdaRecordType\ (A_1 : Kind_1) \cdots (A_n : Kind_n) :
      Set \textbf{ where } \ldots\\
\end{align*}

\begin{align*}
   &DT\llbracket AgdaDataType \rrbracket = \textbf{newtype } HaskellType\ (a_0 :: KT\llbracket Kind_1 \rrbracket)
      \cdots (a_m :: KT\llbracket Kind_m \rrbracket)\\
   &\quad\quad = HaskellType\ (\forall b_0 \cdots b_k.\ DTMA\llbracket AgdaDataType \rrbracket\ b_0\ \cdots\ b_k)\\
   &DT\llbracket AgdaRecordType \rrbracket = \textbf{newtype } HaskellType\ (a_0 :: KT\llbracket Kind_1 \rrbracket)
      \cdots (a_n :: KT\llbracket Kind_n \rrbracket)\\
   &\quad\quad = HaskellType\ (\forall b_0 \cdots b_k.\ DTMA\llbracket AgdaRecordType \rrbracket\ b_0\ \cdots\ b_k)\\
\end{align*}

Transformation for terms:
\begin{align*}
   &Wrap\llbracket AgdaType \rrbracket(MAlonzoTerm) = MyTerm\\
   &Unwrap\llbracket AgdaType \rrbracket(MyTerm) = MAlonzoTerm
\end{align*}

Both are only valid when \(TT\llbracket AgdaType \rrbracket(\varnothing) \neq \bot\)

\begin{align*}
   Wrap\llbracket A\ args\ldots \rrbracket(term) &= \texttt{unsafeCoerce } term\\
   Wrap\llbracket (A : Kind) \rightarrow T \rrbracket(term) &= Wrap\llbracket T \rrbracket(term\ ())\\
   Wrap\llbracket (x : T_1) \rightarrow T_2 \rrbracket(term) &=
      \lambda x.\ Wrap\llbracket T_2 \rrbracket(term\ Unwrap\llbracket T_1 \rrbracket(x))\\
   Wrap\llbracket (x : T_1,\ T_2) \rrbracket((term_1,\ term_2)) &=
      (Wrap\llbracket T_1 \rrbracket(term_1),\ Wrap\llbracket T_2 \rrbracket(term_2))\\
   Wrap\llbracket \_ \rrbracket(term) &= \bot\\
   \\
   Unwrap\llbracket A\ args\ldots \rrbracket(term) &= \texttt{unsafeCoerce } term\\
   Unwrap\llbracket (A : Kind) \rightarrow T \rrbracket(term) &= Unwrap\llbracket T \rrbracket(\lambda \_.\ term)\\
   Unwrap\llbracket (x : T_1) \rightarrow T_2 \rrbracket(term) &=
      \lambda x.\ Unwrap\llbracket T_2 \rrbracket(term\ Wrap\llbracket T_1 \rrbracket(x))\\
   Unwrap\llbracket (x : T_1,\ T_2) \rrbracket((term_1,\ term_2)) &=
      (Unwrap\llbracket T_1 \rrbracket(term_1),\ Unwrap\llbracket T_2 \rrbracket(term_2))\\
   Unwrap\llbracket \_ \rrbracket(term) &= \bot\\
\end{align*}

\section{Preserving type invariants}

Two things to watch for:
\begin{itemize}
\item \texttt{newtype} wrappers in the first case
\item The third case
\end{itemize}
Every other case is exactly the same.

TODO:

\section{Preserving term interface}


\texttt{unsafeCoerce} is legal because it's either:
\begin{itemize}
\item The same term(when its type is a type variable)
\item A newtype around MAlonzo generated type
\item A primitive
\end{itemize}
