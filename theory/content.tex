\section{Intro}

I need to prove that Haskell types and terms that I expose wouldn't break the system.  It means two things:
\begin{enumerate}
\item Types preserve the same set of invariants
\item Terms have the same interface: any combination of \texttt{APPLY} that can be used(ignoring types) to original
      term must be usable with generated one; and primitives(numbers, strings, ... and their ops) are the same.
\end{enumerate}

\section{My transformations}

\subsection{Kinds}
\[ KT\llbracket Kind \rrbracket = HaskellKind \]

\begin{align*}
   KT\llbracket Set_0 \rrbracket &= *\\
   KT\llbracket Kind_1 \rightarrow Kind_2 \rrbracket &=
      KT\llbracket Kind_1 \rrbracket \rightarrow KT\llbracket Kind_2 \rrbracket
\end{align*}

\subsection{Type declarations}

\(DTMA\) gives MAlonzo generated type name.

\(DT,\ DTD\) are defined when \texttt{\{-\# EXPORT} \(AgdaTypeName\) \(HaskellTypeName\) \texttt{\#-\}} is specified.

\begin{align*}
   &DTMA\llbracket AgdaTypeName \rrbracket = HaskellTypeName\\
   &DT\llbracket AgdaTypeName \rrbracket = HaskellTypeName\\
   &DTD\llbracket AgdaTypeName \rrbracket \doteq HaskellTypeDeclaration\\
\end{align*}

Considering declaration:
\begin{align*}
   &\textbf{data } AgdaDataType\ (A_1 : Kind_1) \cdots (A_n : Kind_n) :
      Kind_{n+1} \rightarrow \cdots \rightarrow Kind_{m} \rightarrow Set \textbf{ where } \ldots
\end{align*}

\begin{align*}
   &DTD\llbracket AgdaDataType \rrbracket \doteq\\
   &\quad\textbf{newtype } DT\llbracket AgdaDataType \rrbracket\ (a_0 :: KT\llbracket Kind_1 \rrbracket)
      \cdots (a_m :: KT\llbracket Kind_m \rrbracket)\\
   &\quad\quad = DT\llbracket AgdaRecordType \rrbracket\ (\forall b_0 \cdots b_k.\ DTMA\llbracket AgdaDataType \rrbracket\ b_0\ \cdots\ b_k)
\end{align*}

\(k\) is an arity of type constructor generated by MAlonzo.

It also works for \textbf{record}s.

\subsection{Types}

First about primitives. Only those that are used for postulates are allowed.
MAlonzo gives the following \(PTMA\) transformation:
\begin{align*}
   PTMA\llbracket \texttt{INTEGER} \rrbracket &= Int\\
   PTMA\llbracket \texttt{FLOAT} \rrbracket &= Float\\
   PTMA\llbracket \texttt{CHAR} \rrbracket &= Char\\
   PTMA\llbracket \texttt{STRING} \rrbracket &= String\\
   PTMA\llbracket \texttt{IO} \rrbracket &= IO
\end{align*}

\begin{align*}
   &TT\llbracket AgdaType \rrbracket(Context) = HaskellType\\
   &Context = \{ AgdaTypeVarName \mapsto HaskellTypeVarName \}
\end{align*}

\begin{align*}
   TT\llbracket A\ args\ldots \rrbracket(\Gamma) &= a\ TT\llbracket args\ldots \rrbracket(\Gamma),
      \quad (A \mapsto a) \in \Gamma \\
   TT\llbracket CT\ args\ldots \rrbracket(\Gamma) &= CT\ TT\llbracket args\ldots \rrbracket(\Gamma),
      \quad CT\text{ is a \texttt{COMPILED\_TYPE}}\\
   TT\llbracket PT\ args\ldots \rrbracket(\Gamma) &= PTMA\llbracket PT \rrbracket\ TT\llbracket args\ldots \rrbracket(\Gamma) \\
   TT\llbracket ET\ args\ldots \rrbracket(\Gamma) &= DT\llbracket ET \rrbracket \ TT\llbracket args\ldots \rrbracket(\Gamma)\\
   TT\llbracket (A : Kind) \rightarrow T \rrbracket(\Gamma) &= \forall (a :: KT\llbracket Kind \rrbracket).
      \ TT\llbracket T \rrbracket(\Gamma \cup \{A \mapsto a\})\\
   TT\llbracket (x : T_1) \rightarrow T_2 \rrbracket(\Gamma) &=
      TT\llbracket T_1 \rrbracket(\Gamma) \rightarrow TT\llbracket T_2 \rrbracket(\Gamma),
      \quad x \not\in freevars(T_2) \\
   TT\llbracket (x : T_1,\ T_2) \rrbracket(\Gamma) &=
      (TT\llbracket T_1 \rrbracket(\Gamma),\ TT\llbracket T_2 \rrbracket(\Gamma)),
      \quad x \not\in freevars(T_2) \\
\end{align*}

\subsection{Terms}

\(Wrap\) is defined only when \(TT\llbracket AgdaType \rrbracket(\varnothing)\) is defined.

\begin{align*}
   &Wrap^{2k}\llbracket AgdaType \rrbracket(MAlonzoTerm) = MyTerm\\
   &Wrap^{2k + 1}\llbracket AgdaType \rrbracket(MyTerm) = MAlonzoTerm
\end{align*}

\begin{align*}
   Wrap^k\llbracket A\ args\ldots \rrbracket(term) &= \texttt{unsafeCoerce } term\\
   Wrap^{2k}\llbracket (A : Kind) \rightarrow T \rrbracket(term) &= Wrap^{2k}\llbracket T \rrbracket(term\ ())\\
   Wrap^{2k+1}\llbracket (A : Kind) \rightarrow T \rrbracket(term) &= Wrap^{2k+1}\llbracket T \rrbracket(\lambda \_.\ term)\\
   Wrap^k\llbracket (x : T_1) \rightarrow T_2 \rrbracket(term) &=
      \lambda x.\ Wrap^k\llbracket T_2 \rrbracket(term\ Wrap^{k+1}\llbracket T_1 \rrbracket(x))\\
   Wrap^k\llbracket (x : T_1,\ T_2) \rrbracket((term_1,\ term_2)) &=
      (Wrap^k\llbracket T_1 \rrbracket(term_1),\ Wrap^k\llbracket T_2 \rrbracket(term_2))
\end{align*}

\subsection{Value declarations}

\(VTMA\) gives MAlonzo generated value name

\(VT,\ VTD\) are defined when \texttt{\{-\# EXPORT} \(AgdaName\) \(HaskellName\) \texttt{\#-\}} is specified.

\begin{align*}
   &VTMA\llbracket AgdaName \rrbracket = HaskellName\\
   &VT\llbracket AgdaName \rrbracket = HaskellName\\
   &VTD\llbracket AgdaName \rrbracket \doteq HaskellDeclaration\\
\end{align*}

Considering declaration:
\begin{align*}
   &AgdaName : AgdaType\\
   &AgdaName = \ldots
\end{align*}

\begin{align*}
   &VTD\llbracket AgdaName \rrbracket \doteq\\
   &\quad\quad VT\llbracket AgdaName \rrbracket :: TT\llbracket AgdaType \rrbracket(\varnothing)\\
   &\quad\quad VT\llbracket AgdaName \rrbracket = Wrap^0\llbracket AgdaType \rrbracket(VTMA\llbracket AgdaName \rrbracket)\\
\end{align*}

It works in the same way for constructors(it exports them as Haskell functions - not Haskell constructors).
It also works seamlessly with parametrized modules and, consequently, with record functions.

\section{Preserving type invariants}

Three cases:
\begin{enumerate}
\item \texttt{newtype} wrappers.

A datatype can be viewed as a logical statement and its constructors --- as
proofs of this statement. \texttt{newtype} wrapping gives us a statement but
hides proofs. Acquiring an instance of this datatype in Haskell can only be done
when some Agda function returns it. Therefore it was constructed with all the invariants
checked by Agda. We can only use this datatype with functions exported from Agda that
used the original version of it. Therefore all the internal invariants are safely passed
from Agda to Agda invisibly through Haskell.

\item Transformation from Church polymorphism to Curry polymorphism.

\begin{align*}
&(A : Kind) \rightarrow Type \\
&(\forall a :: KT\llbracket Kind \rrbracket).\ HaskellType
\end{align*}

They both mean the same thing but the first one always requires a proof that
\(Kind\) is inhabited:

\begin{itemize}
\item If \(A \not\in freevars(Type)\) and, by construction(\(TT\)), \(a \not\in freevars(HaskellType)\).
\item \(A\) (and consequently \(a\)) is a phantom type(i.e. only used as a type parameter).
\end{itemize}

In both cases Haskell will completely ignore the inhabitance of \(KT\llbracket Kind \rrbracket\).
Agda however will require you to provide an evidence that \(Kind\) can be constructed. Now,
\(Kind\) is defined as a combination of \(Set_0\) and arrows. Therefore some \(Kind\ A\) can be viewed as
follows: \(Arg_1 \rightarrow \ldots \rightarrow Arg_n \rightarrow Set_0\) for \(n \ge 0\).
Let's define a simple \(Unit\) type:
\begin{align*}
   &\mathbf{data}\ Unit : Set\ \mathbf{where}\\
   &\quad unit : Unit
\end{align*}

We can now construct an \(A\): \(A = \lambda arg_1 \ldots arg_n.\ Unit\). Therefore, each \(Kind\)
is inhabited and we can safely omit this proof in our transformation.

\item In every other case type is exactly the same.

So invariants are clearly the same.
\end{enumerate}

\section{Preserving term interface}

\(Wrap\) clearly deals with the issue of passing and skipping type parameters with
MAlonzo-generated code.

A thing to watch for is \texttt{unsafeCoerce}.
There are three cases for a coerced type:
\begin{enumerate}
\item a \texttt{newtype} wrapper around an MAlonzo-generated datatype.

   Safe because \texttt{newtype} is required to have the same
   internal structure as its wrapped type.
\item a primitive as defined by \(PTMA\).

   Safe because type of MAlonzo-generated code is the same as ours by construction.
\item \(a\ args\ldots\), where \(a\) is a type variable.

   Safe because all terms with type \(a\ args\ldots\) will have the same internal
   structure. That's because from Haskell side compiler will guarantee that and
   from Agda side terms will have a corresponding type \(A\ args\ldots\) (via \(\Gamma\) in \(TT\))
   so the compiler will guarantee it too.
\end{enumerate}
