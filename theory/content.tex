\section{Intro}

I need to prove that haskell types and terms that I expose wouldn't break the system.  It means two things:
\begin{enumerate}
\item Types preserve the same set of invariants
\item Terms have the same interface: any combination of \texttt{APPLY} that can be used to original(ignoring types)
      term must be usable with generated; and primitives(numbers, strings, ... and their ops) are the same.
\end{enumerate}

\section{Preserving type invariants}

Conversion for types:\\
\(TT\llbracket AgdaType \rrbracket(Context) = HaskellType \)
\begin{align*}
   TT\llbracket A\ args\ldots \rrbracket(\Gamma) &= a\ TT\llbracket args\ldots \rrbracket(\Gamma),
      \quad (A \mapsto a) \in \Gamma \\
   TT\llbracket CT\ args\ldots \rrbracket(\Gamma) &= CT\ TT\llbracket args\ldots \rrbracket(\Gamma),
      \quad CT\text{ is a \texttt{COMPILED\_TYPE}, \texttt{EXPORT} or a primitive postulate}\\
   TT\llbracket (A : Kind) \rightarrow T \rrbracket(\Gamma) &= \forall a.\ TT\llbracket T \rrbracket(\Gamma \cup (A \mapsto a)),
      \quad Kind\text{ is a combination of \(Set\) and arrows}\\
   TT\llbracket (x : T_1) \rightarrow T_2 \rrbracket(\Gamma) &=
      TT\llbracket T_1 \rrbracket(\Gamma) \rightarrow TT\llbracket T_2 \rrbracket(\Gamma),
      \quad x \not\in freevars(T_2) \\
   TT\llbracket (x : T_1,\ T_2) \rrbracket(\Gamma) &=
      (TT\llbracket T_1 \rrbracket(\Gamma),\ TT\llbracket T_2 \rrbracket(\Gamma)),
      \quad x \not\in freevars(T_2) \\
   TT\llbracket \_ \rrbracket(\Gamma) &= \bot\\
\end{align*}
Two things to watch for:
\begin{itemize}
\item \texttt{newtype} wrappers in the first case
\item The third case
\end{itemize}
Every other case is exactly the same.

TODO:

\section{Preserving term interface}

Conversion for terms:\\
\(Wrap\llbracket AgdaType \rrbracket(MAlonzoTerm) = MyTerm \)\\
\(Unwrap\llbracket AgdaType \rrbracket(MyTerm) = MAlonzoTerm \)\\
Both are only valid when \(TT\llbracket AgdaType \rrbracket(\varnothing) \neq \bot\)
\begin{align*}
   Wrap\llbracket A\ args\ldots \rrbracket(term) &= \texttt{unsafeCoerce } term\\
   Wrap\llbracket (A : Kind) \rightarrow T \rrbracket(term) &= Wrap\llbracket T \rrbracket(term\ ())\\
   Wrap\llbracket (x : T_1) \rightarrow T_2 \rrbracket(term) &=
      \lambda x.\ Wrap\llbracket T_2 \rrbracket(term\ Unwrap\llbracket T_1 \rrbracket(x))\\
   Wrap\llbracket (x : T_1,\ T_2) \rrbracket((term_1,\ term_2)) &=
      (Wrap\llbracket T_1 \rrbracket(term_1),\ Wrap\llbracket T_2 \rrbracket(term_2))\\
   Wrap\llbracket \_ \rrbracket(term) &= \bot\\
   \\
   Unwrap\llbracket A\ args\ldots \rrbracket(term) &= \texttt{unsafeCoerce } term\\
   Unwrap\llbracket (A : Kind) \rightarrow T \rrbracket(term) &= Unwrap\llbracket T \rrbracket(\lambda \_.\ term)\\
   Unwrap\llbracket (x : T_1) \rightarrow T_2 \rrbracket(term) &=
      \lambda x.\ Unwrap\llbracket T_2 \rrbracket(term\ Wrap\llbracket T_1 \rrbracket(x))\\
   Unwrap\llbracket (x : T_1,\ T_2) \rrbracket((term_1,\ term_2)) &=
      (Unwrap\llbracket T_1 \rrbracket(term_1),\ Unwrap\llbracket T_2 \rrbracket(term_2))\\
   Unwrap\llbracket \_ \rrbracket(term) &= \bot\\
\end{align*}
\texttt{unsafeCoerce} is legal because it's either:
\begin{itemize}
\item The same term(when its type is a type variable)
\item A newtype around MAlonzo generated type
\item A primitive
\end{itemize}
